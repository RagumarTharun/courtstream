<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>CourtStream – Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ef4444' stroke-width='2'><circle cx='12' cy='12' r='10'/><path d='M9.5 8l6 4-6 4V8z' fill='white' stroke='none'/></svg>">

  <style>
    :root {
      --bg: #0f1115;
      --panel: #161922;
      --border: #262b3d;
      --text: #e6e6eb;
      --muted: #9aa0b4;
      --blue: #3b82f6;
      --red: #ef4444;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ===== LAYOUT ===== */
    .viewer-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ===== PLAYER (LEFT/TOP) ===== */
    .player-container {
      flex: 1;
      background: #000;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    video {
      width: 100%;
      height: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    /* ===== MOBILE RWD ===== */
    @media (max-width: 900px) {
      .viewer-layout {
        flex-direction: column;
      }

      .player-container {
        flex: initial;
        width: 100%;
        height: 100vh;
      }

      /* Feedback Button overrides for Mobile */
      .feedback-fab {
        top: 20px !important;
        right: 20px !important;
        bottom: auto !important;
        width: 40px !important;
        height: 40px !important;
      }

      .feedback-fab svg {
        width: 18px !important;
        height: 18px !important;
      }
    }

    /* Feedback Button overrides for Desktop */
    @media (min-width: 901px) {
      .feedback-fab {
        top: 24px !important;
        right: 380px !important;
        bottom: auto !important;
      }
    }
  </style>
</head>

<body>

  <div class="viewer-layout">
    <!-- PLAYER -->
    <div class="player-container">
      <video id="v" autoplay muted playsinline></video>

      <div class="stream-info">
        <div class="badge">
          <div class="live-dot"></div>
          <span id="streamName">Live Stream</span>
        </div>
      </div>

      <button class="react-btn" onclick="toggleFullscreen()"
        style="position:absolute; bottom:20px; right:20px; z-index:10;">⛶</button>
    </div>
  </div>

  <!-- ENTRY / PASSCODE OVERLAYS (Reusing same logic structure) -->
  style="display:none;position:fixed;inset:0;background:rgba(15,17,21,0.95);z-index:100;align-items:center;justify-content:center;flex-direction:column;padding:20px;text-align:center;">
  <h3 style="margin-top:0;">Secured Stream</h3>
  <input type="password" id="passInput" placeholder="Enter Passcode"
    style="background:var(--bg);border:1px solid var(--border);color:#fff;padding:12px;border-radius:8px;width:100%;max-width:240px;text-align:center;font-size:18px;margin-bottom:16px;">
  <button id="joinBtn"
    style="padding:10px 24px;background:var(--blue);border:none;border-radius:8px;font-weight:600;color:white;cursor:pointer;">
    Join Stream
  </button>
  <div id="errorMsg" style="color:var(--red);font-size:12px;margin-top:12px;display:none;">Invalid passcode</div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="feedback.js"></script>
  <script>
    const socket = io();
    const params = new URLSearchParams(location.search);
    const streamId = params.get("stream");
    const streamName = params.get("name") || "Stream";
    let myName = "Guest " + Math.floor(Math.random() * 1000);

    // Update UI
    document.getElementById("streamName").innerText = streamName;

    /* ===== WEBRTC LOGIC (Existing) ===== */
    const video = document.getElementById("v");
    let pc;
    let turnConfig = null;
    let directorId = null;

    async function getTurnConfig() {
      if (turnConfig) return turnConfig;
      const res = await fetch("/api/turn-credentials");
      turnConfig = await res.json();
      return turnConfig;
    }

    // Access Gates
    const passOverlay = document.getElementById("passcodeOverlay");
    const passInput = document.getElementById("passInput");
    const errorMsg = document.getElementById("errorMsg");

    document.getElementById("joinBtn").onclick = () => {
      const pass = passInput.value.trim();
      if (pass) socket.emit("join", { room: streamId, role: "viewer", password: pass });
    }

    async function checkAccess() {
      // ... (Similar logic to before, simplified)
      const res = await fetch("/api/streams");
      const all = await res.json();
      const stream = all.find(s => s.id === streamId);

      if (stream && stream.viewer_access === "protected") {
        passOverlay.style.display = "flex";
      } else {
        socket.emit("join", { room: streamId, role: "viewer" });
      }
    }

    socket.on("join-error", () => {
      passOverlay.style.display = "flex";
      errorMsg.style.display = "block";
    });

    socket.on("join-success", () => {
      passOverlay.style.display = "none";
    });

    function setupPeerHooks() {
      pc.ontrack = e => {
        const stream = e.streams[0] || new MediaStream([e.track]);
        video.srcObject = stream;
        video.play().catch(console.warn);
      };
      pc.onicecandidate = e => {
        if (e.candidate) {
          if (directorId) socket.emit("signal", { to: directorId, data: e.candidate });
        }
      };
    }

    let pendingCandidates = [];

    async function initPC() {
      if (pc) {
        pc.close();
      }
      const config = await getTurnConfig();
      pc = new RTCPeerConnection(config);
      setupPeerHooks();
      pendingCandidates = [];
    }

    socket.on("signal", async ({ from, data }) => {
      if (data.type === "offer") {
        directorId = from;
        try {
          // If receiving an offer, the director might have refreshed, so reset the PC
          await initPC();
          await pc.setRemoteDescription(new RTCSessionDescription(data));
          const ans = await pc.createAnswer();
          await pc.setLocalDescription(ans);
          socket.emit("signal", { to: from, data: ans });

          // Flush buffered candidates
          while (pendingCandidates.length > 0) {
            const cand = pendingCandidates.shift();
            await pc.addIceCandidate(new RTCIceCandidate(cand)).catch(e => console.warn("ICE error:", e));
          }
        } catch (e) {
          console.error("Signal Handling Error:", e);
        }
      } else if (data.candidate || data.sdpMid) {
        if (pc.remoteDescription) {
          pc.addIceCandidate(new RTCIceCandidate(data)).catch(console.warn);
        } else {
          pendingCandidates.push(data);
        }
      }
    });

    function toggleFullscreen() {
      const el = document.querySelector(".player-container");
      if (!document.fullscreenElement) el.requestFullscreen();
      else document.exitFullscreen();
    }

    async function initViewer() {
      await initPC();
      checkAccess();
    }

    // Auto-init on load
    initViewer();
  </script>
</body>

</html>