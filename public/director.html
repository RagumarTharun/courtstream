<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>CourtStream ‚Äì Director</title>
  <script src="modal.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ef4444' stroke-width='2'><circle cx='12' cy='12' r='10'/><path d='M9.5 8l6 4-6 4V8z' fill='white' stroke='none'/></svg>">

  <style>
    :root {
      --bg: #0f1115;
      --panel: #161922;
      --border: #262b3d;
      --text: #e6e6eb;
      --muted: #9aa0b4;
      --red: #ef4444;
      --blue: #3b82f6;
      --green: #22c55e;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui;
      height: 100vh;
    }

    /* Switch Toggle */
    .switch {
      position: relative;
      display: inline-block;
      width: 34px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--panel);
      border: 1px solid var(--border);
      transition: .4s;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 12px;
      width: 12px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
    }

    input:checked+.slider {
      background-color: var(--blue);
    }

    input:checked+.slider:before {
      transform: translateX(14px);
    }

    .slider.round {
      border-radius: 20px;
    }

    .slider.round:before {
      border-radius: 50%;
    }

    /* LAYOUT - GRID */
    .director {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 14px;
      padding: 14px;
      height: 100%;
    }

    /* ===== PANELS ===== */
    .panel {
      background: var(--panel);
      border-radius: 16px;
      border: 1px solid var(--border);
    }

    /* ===== MAIN PREVIEW ===== */
    .main-feed {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      overflow: hidden;
    }

    /* Fixed preview size */
    .main-feed::before {
      content: "";
      display: block;
      padding-top: 56.25%;
    }

    .main-feed video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      transform-origin: center center;
    }

    /* Placeholder */
    .placeholder {
      position: absolute;
      color: var(--muted);
      font-size: 14px;
      z-index: 2;
    }

    /* Top-left badge */
    .stream-badge {
      position: absolute;
      top: 14px;
      left: 14px;
      background: rgba(15, 17, 21, .85);
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 13px;
      z-index: 2;
    }

    /* Record badge */
    .record-bar {
      position: absolute;
      bottom: 14px;
      left: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(15, 17, 21, .85);
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 13px;
      z-index: 2;
    }

    .record-dot {
      width: 10px;
      height: 10px;
      background: var(--red);
      border-radius: 50%;
    }

    /* Top-right controls */
    .main-controls {
      position: absolute;
      top: 14px;
      right: 14px;
      display: flex;
      gap: 8px;
      z-index: 2;
    }

    .ctrl-btn {
      border: none;
      background: rgba(15, 17, 21, .85);
      border: 1px solid var(--border);
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .ctrl-btn:hover {
      background: var(--border);
    }

    .ctrl-btn.active {
      background: var(--red);
      border-color: var(--red);
    }

    /* RENDER SPINNER */
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* ===== RIGHT CAMERA STRIPE ===== */
    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      overflow-y: auto;
    }

    .side-title {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .camera-slot {
      background: #000;
      border-radius: 14px;
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
      cursor: pointer;
      flex-shrink: 0;
      padding-top: 6px;
    }

    .camera-slot video {
      width: 100%;
      height: 140px;
      object-fit: contain;
      background: #000;
      transform-origin: center center;
    }

    .camera-slot span {
      position: absolute;
      bottom: 8px;
      left: 8px;
      font-size: 12px;
      background: rgba(0, 0, 0, .6);
      padding: 4px 8px;
      border-radius: 999px;
      color: #fff;
    }

    .camera-name {
      width: 100%;
      border: none;
      background: transparent;
      color: #fff;
      font-size: 12px;
      padding: 6px 10px 4px;
      outline: none;
    }

    .camera-actions {
      position: absolute;
      top: 6px;
      right: 6px;
      display: flex;
      gap: 6px;
      z-index: 2;
    }

    .mini-btn {
      border: none;
      background: rgba(15, 17, 21, .85);
      border: 1px solid var(--border);
      color: #fff;
      padding: 4px 6px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 10px;
    }

    /* ===== MODALS ===== */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .6);
      z-index: 20;
    }

    .modal-box {
      background: #161922;
      border-radius: 14px;
      padding: 20px;
      width: 340px;
      text-align: center;
      border: 1px solid #262b3d;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .modal-box h3 {
      margin: 0 0 10px
    }

    .modal-actions {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 12px;
    }

    .modal video {
      width: 100%;
      border-radius: 10px;
      background: #000;
    }

    /* ===== MOBILE RWD ===== */
    @media (max-width: 900px) {
      .director {
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      .panel.main-feed {
        width: 100%;
        aspect-ratio: 16/9;
        flex-grow: 0;
        flex-shrink: 0;
        margin-bottom: 0;
        /* Remove the top padding hack for mobile flex */
        padding-top: 0;
      }

      .main-feed::before {
        display: none;
        /* Disable the aspect ratio hack since we use aspect-ratio property or rely on flex */
      }

      .main-feed video {
        position: relative;
        /* Normal flow */
        width: 100%;
        height: 100%;
      }

      .side-panel {
        flex: 1;
        width: 100%;
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 10px;
        gap: 10px;
        border-left: none;
        border-top: 1px solid var(--border);
        align-items: center;
      }

      .side-title {
        display: none;
      }

      .camera-slot {
        width: 160px;
        min-width: 160px;
        height: 90%;
        border-radius: 10px;
      }

      .camera-slot video {
        height: 100%;
        max-height: 120px;
      }

      .modal-box {
        width: 90%;
        max-width: 320px;
      }
    }

    /* DASHBOARD OVERLAY */
    #transferModal {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 20000;
      /* display: flex; set by JS */
      flex-direction: column;
      padding: 40px;
      overflow-y: auto;
    }

    .dashboard-header {
      text-align: center;
      margin-bottom: 40px;
    }

    .dashboard-header h1 {
      font-size: 24px;
      margin: 0;
      color: white;
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 20px;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
      /* height: 100%; // remove height constraints for scrolling */
    }

    .dashboard-col {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-height: 400px;
    }

    .dashboard-col h2 {
      font-size: 13px;
      margin: 0 0 20px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
    }

    .status-badge {
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      background: #334155;
      color: #94a3b8;
      font-weight: 600;
    }

    .status-badge.processing {
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
    }

    .status-badge.success {
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
    }

    .status-badge.pending {
      background: rgba(148, 163, 184, 0.1);
      color: #64748b;
    }

    .status-badge.error {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .file-item {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      /* allow for progress bar under text */
      gap: 4px;
      margin-bottom: 8px;
    }

    .file-item>div:first-child {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }

    .dash-progress {
      height: 6px;
      background: #334155;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
      width: 100%;
    }

    .dash-fill {
      height: 100%;
      background: #3b82f6;
      transition: width 0.3s ease;
    }

    /* Mobile adjustments for dashboard */
    @media (max-width: 900px) {
      .dashboard-grid {
        grid-template-columns: 1fr;
        height: auto;
      }
    }

    .dash-btn {
      padding: 12px 20px;
      border-radius: 8px;
      border: 1px solid var(--border);
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .dash-btn:hover {
      filter: brightness(1.1);
      border-color: var(--blue);
    }

    .btn-premium {
      background: var(--blue);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-premium:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
  </style>
</head>

<body>

  <div class="director">

    <!-- MAIN PREVIEW -->
    <div class="panel main-feed">
      <video id="mainVideo" autoplay muted playsinline></video>
      <div id="placeholder" class="placeholder">Select a camera to preview</div>

      <div class="stream-badge" id="streamBadge"></div>

      <div class="main-controls">
        <!-- ISO TOGGLE -->


        <!-- RECORD -->
        <button id="recordBtn" class="ctrl-btn" title="Record" onclick="toggleRecord()">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="8" fill="white" class="rec-icon" />
            <rect x="6" y="6" width="12" height="12" fill="white" class="stop-icon" style="display:none" />
          </svg>
        </button>

        <!-- PLAYBACK -->
        <button id="playbackBtn" class="ctrl-btn" title="Playback Editor" onclick="goToPlayback()">
          <svg viewBox="0 0 24 24">
            <path fill="white"
              d="M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" />
          </svg>
        </button>

        <!-- QR CODE -->
        <button id="qrBtn" class="ctrl-btn" title="Camera QR Code" onclick="openQr()">
          <svg viewBox="0 0 24 24">
            <path fill="white"
              d="M3 11h8V3H3v8zm2-6h4v4H5V5zM3 21h8v-8H3v8zm2-6h4v4H5v-4zM13 3v8h8V3h-8zm6 6h-4V5h4v4zM13 13h2v2h-2v-2zm2 2h2v2h-2v-2zm2-2h2v2h-2v-2zm2 2h2v2h-2v-2zm0-2h2v2h-2v-2zm-6 4h2v2h-2v-2zm2 2h2v2h-2v-2zm2-2h2v2h-2v-2z" />
          </svg>
        </button>
      </div>

      <div class="record-bar" id="recordBar" style="display:none;">
        <div class="record-dot"></div>
        <div id="recordTimer">00:00:00</div>
        <div id="recordStatus" style="color:var(--muted);font-size:12px;">REC</div>
      </div>
    </div>

    <!-- RIGHT CAMERA STRIPE -->
    <div class="panel side-panel" id="cameraStrip">
      <div class="side-title">
        <span>Cameras</span>
      </div>
    </div>

  </div>

  <canvas id="programCanvas" width="1280" height="720"
    style="position:fixed;left:-9999px;top:0;opacity:0;pointer-events:none;"></canvas>

  <!-- QR MODAL -->
  <div class="modal" id="qrModal">
    <div class="modal-box">
      <h3>Scan to Join as Camera</h3>
      <div id="qrCode" style="background:#fff;padding:10px;border-radius:8px;"></div>
      <div style="font-size:12px;color:var(--muted);margin-top:8px;word-break:break-all;" id="qrLink"></div>
      <div class="modal-actions">
        <button class="ctrl-btn" onclick="closeQr()"
          style="width:auto;height:auto;padding:8px 16px;border-radius:8px;">Close</button>
      </div>
    </div>
  </div>

  <!-- MOBILE WARNING MODAL -->
  <div class="modal" id="mobileWarning" style="z-index:9999;">
    <div class="modal-box">
      <h3>‚ö†Ô∏è Desktop Recommended</h3>
      <p style="color:var(--muted);font-size:14px;margin-bottom:20px;">
        The Director dashboard is optimized for larger screens. For the best experience, please use a laptop or desktop.
      </p>
      <div class="modal-actions">
        <button class="ctrl-btn" onclick="document.getElementById('mobileWarning').style.display='none'">
          Continue Anyway
        </button>
      </div>
    </div>
  </div>

  <!-- STOP RECORDING MODAL -->
  <div class="modal" id="stopModal" style="z-index:10000;">
    <div class="modal-box" style="width: 400px; max-width: 90%;">
      <h3>Stop Recording</h3>
      <p style="color:var(--muted);font-size:14px;margin-bottom:20px;">
        Choose how you want to save this session.
      </p>

      <div style="display:flex; flex-direction:column; gap:10px; width:100%;">
        <!-- Option 1: Quality (ISO) -->
        <button class="ctrl-btn" onclick="showQualityOptions()"
          style="width:100%; border-radius:8px; justify-content:space-between; padding:0 16px;">
          <div style="text-align:left;">
            <div style="font-weight:600;">Quality Feed (ISO)</div>
            <div style="font-size:11px; color:var(--muted);">Process & Download from Server</div>
          </div>
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor"
              d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z" />
          </svg>
        </button>

        <!-- Option 2: Instant (Local) -->
        <button class="ctrl-btn" onclick="confirmInstantSave()"
          style="width:100%; border-radius:8px; justify-content:space-between; padding:0 16px;">
          <div style="text-align:left;">
            <div style="font-weight:600;">Instant Feed</div>
            <div style="font-size:11px; color:var(--muted);">Download Direct from Browser</div>
          </div>
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor" d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z" />
          </svg>
        </button>

        <!-- Option 3: Both -->
        <button class="ctrl-btn" onclick="confirmBothSave()"
          style="width:100%; border-radius:8px; justify-content:space-between; padding:0 16px;">
          <div style="text-align:left;">
            <div style="font-weight:600;">Both</div>
            <div style="font-size:11px; color:var(--muted);">Download Local & Process Server</div>
          </div>
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor"
              d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z" />
          </svg>
        </button>
      </div>

      <div class="modal-actions" style="margin-top:20px;">
        <button class="ctrl-btn" onclick="closeStopModal()"
          style="background:transparent; border:none; color:var(--muted);">Cancel</button>
      </div>
    </div>
  </div>

  <!-- QUALITY SUB-MODAL -->
  <div class="modal" id="qualitySubModal" style="z-index:10001;">
    <div class="modal-box" style="width: 360px;">
      <h3>Quality Feed Options</h3>
      <p style="color:var(--muted);font-size:14px;margin-bottom:20px;">
        Which feeds do you want to process?
      </p>

      <div style="display:flex; flex-direction:column; gap:10px; width:100%;">
        <button class="ctrl-btn" onclick="handleQualitySave('quality_all')"
          style="width:100%; border-radius:8px; padding:12px;">
          All Camera Feeds + Program
        </button>
        <button class="ctrl-btn" onclick="handleQualitySave('quality_program')"
          style="width:100%; border-radius:8px; padding:12px;">
          Program Feed Only (Edited)
        </button>
      </div>

      <div class="modal-actions" style="margin-top:20px;">
        <button class="ctrl-btn" onclick="closeQualitySubModal()"
          style="background:transparent; border:none; color:var(--muted);">Back</button>
      </div>
    </div>
  </div>

  <!-- POST-PRODUCTION DASHBOARD (FAKE REDIRECT) -->
  <!-- POST-PRODUCTION DASHBOARD (FAKE REDIRECT) -->
  <div id="transferModal" style="display:none; z-index: 20000;">
    <div class="dashboard-header">
      <h1>üé¨ Post-Production Studio</h1>
      <div style="color: #94a3b8; font-size: 14px; margin-top: 8px;">Processing your session... Do not close this tab.
      </div>
    </div>

    <div class="dashboard-grid">
      <!-- COL 1: INSTANT EXPORTS -->
      <div class="dashboard-col">
        <h2>
          <span>‚ö° Instant Exports</span>
          <span class="status-badge success">READY</span>
        </h2>
        <div id="instantList">
          <!-- Populated dynamically -->
        </div>
        <div style="margin-top: auto; padding-top: 16px; border-top: 1px solid #334155;">
          <div style="font-size: 12px; color: #94a3b8; margin-bottom: 8px;">Files saved to your Downloads folder.</div>
        </div>
      </div>

      <!-- COL 2: SOURCE TRANSFERS -->
      <div class="dashboard-col">
        <h2>
          <span>üì° Source Transfers</span>
          <span id="transferStatusBadge" class="status-badge processing">ACTIVE</span>
        </h2>
        <div id="transferList" style="display: flex; flex-direction: column; gap: 8px;">
          <!-- Dynamic Transfer Rows -->
        </div>
      </div>

      <!-- COL 3: FINAL RENDER -->
      <div class="dashboard-col">
        <h2>
          <span>üéûÔ∏è Final Render</span>
          <span id="renderStatusBadge" class="status-badge pending">WAITING</span>
        </h2>

        <div id="renderPhase" style="display: none;">
          <div style="margin-bottom: 8px; color: #e2e8f0; font-size: 14px;" id="renderStatusText">Waiting for sources...
          </div>
          <div class="dash-progress">
            <div id="renderProgressBar" class="dash-fill"></div>
          </div>
        </div>

        <div id="completePhase" style="display: none; margin-top: 16px;">
          <div class="file-item"
            style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.2);">
            <span style="color: #10b981; font-weight: 600;">‚úÖ Done!</span>
          </div>
          <div id="downloadButtons"></div>
          <div style="display: flex; gap: 12px; margin-top: 24px;">
            <button class="dash-btn" onclick="showDownloadSelectionModal()"
              style="background: var(--blue); flex: 2; border: none;">Process More Files</button>
            <button class="dash-btn" onclick="location.reload()" style="background: #334155; flex: 1;">New
              Session</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="/lib/ffmpeg/ffmpeg.js"></script>
  <script src="/lib/ffmpeg/ffmpeg-util.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script>
    /* ===== STREAM INFO ===== */
    const params = new URLSearchParams(location.search);
    const streamId = params.get("stream");
    let streamName = params.get("name");
    let streamLabel = "";

    // Mobile Warning Check
    if (window.innerWidth < 900) {
      document.getElementById("mobileWarning").style.display = "flex";
    }

    async function updateStreamBadge() {
      let name = streamName;

      if (!name && streamId) {
        try {
          const res = await fetch("/api/streams");
          if (res.ok) {
            const streams = await res.json();
            const match = streams.find(s => s.id === streamId);
            if (match) name = match.name;
          }
        } catch {
          // fallback below
        }
      }

      const label = name || streamId || "Unknown Stream";
      streamLabel = label;
      document.getElementById("streamBadge").innerText =
        label + " ‚Ä¢ LIVE";
    }
    updateStreamBadge();

    /* ===== SOCKET / STATE ===== */
    const socket = io();
    const mainVideo = document.getElementById("mainVideo");
    const placeholder = document.getElementById("placeholder");
    const strip = document.getElementById("cameraStrip");
    const programCanvas = document.getElementById("programCanvas");
    const programCtx = programCanvas.getContext("2d");

    const peers = {};      // camera socketId -> { pc, stream, slot, name }
    const viewers = {};    // viewer socketId -> { pc, sender }
    const rotations = {}; // socketId -> rotation degrees
    let activeCameraId = null; // Fix: Declare missing state variable
    let currentLiveId = null;
    const pendingViewers = new Set();

    let programStream = programCanvas.captureStream(30);
    mainVideo.srcObject = programStream;
    mainVideo.onloadedmetadata = () => mainVideo.play().catch(() => { });

    let selectedStream = null;
    let drawLoopRunning = false;

    /* ===== RECORDING ===== */
    let recordingState = "idle"; // idle | recording | paused
    let recordStartTime = 0;
    let recordTimerInt = null;
    let programRecorder = null;
    const programChunks = [];
    const cameraRecorders = {}; // id -> { recorder, chunks }

    // Safety Lock for FFmpeg to prevent "Both" mode collision
    let isDownloadingInstant = false;
    let isRenderPending = false;

    /* ===== EXISTING PEERS ===== */
    socket.on("existing-peers", peersList => {
      console.log("üë• Existing peers:", peersList);
      if (!Array.isArray(peersList)) return;

      const activeIds = new Set(peersList.map(p => p.id));

      // 1. Add new peers
      peersList.forEach(({ id, role, clientId }) => {
        if (!id || id === socket.id) return;
        if (role === "viewer") {
          if (!viewers[id]) queueOrCreateViewer(id);
          return;
        }
        if (role === "director") return;

        // Deduplication by clientId
        if (clientId) {
          const oldId = Object.keys(peers).find(pid => peers[pid].clientId === clientId);
          if (oldId && oldId !== id) {
            console.log("‚ôªÔ∏è Duplicate camera detected via clientId, replacing:", clientId);
            removePeer(oldId);
          }
        }

        if (!peers[id]) createPeer(id, clientId);
      });

      // 2. Garbage Collect Stale Peers
      Object.keys(peers).forEach(id => {
        if (!activeIds.has(id)) {
          console.warn("üßπ Removing stale peer (GC):", id);
          removePeer(id);
        }
      });
    });

    /* ===== PEER JOINED ===== */
    socket.on("peer-joined", ({ id, role, clientId }) => {
      console.log("üë§ Peer joined:", id, "role:", role, "clientId:", clientId);
      if (!id || id === socket.id) return;
      if (role === "viewer") {
        if (viewers[id]) return;
        queueOrCreateViewer(id);
        return;
      }
      if (role === "director") return;

      // Deduplication by clientId
      if (clientId) {
        const oldId = Object.keys(peers).find(pid => peers[pid].clientId === clientId);
        if (oldId && oldId !== id) {
          console.log("‚ôªÔ∏è Duplicate camera detected on join, replacing:", clientId);
          removePeer(oldId);
        }
      }

      if (peers[id]) return;
      createPeer(id, clientId);
    });

    /* ===== JOIN ===== */
    socket.emit("join", { room: streamId, role: "director" });

    // Proactive Discovery: Poll for peers every 5 seconds to catch missed joins
    setInterval(() => {
      socket.emit("join", { room: streamId, role: "director" }); // Re-emit join to trigger server-side existing-peers list
    }, 5000);

    socket.on("viewer-ready", ({ id }) => {
      console.log("üëÄ Viewer ready:", id);
      if (!id) return;
      if (!viewers[id]) {
        createViewerPeer(id);
      } else {
        console.log("üëÄ Viewer already exists, swapping track to current live");
        updateViewerFeeds();
      }
    });

    /* ===== PEER LEFT ===== */
    function removePeer(id) {
      const p = peers[id];
      if (!p) return;

      p.pc.close();
      p.slot.remove();
      delete peers[id];
      delete rotations[id];

      if (currentLiveId === id) {
        currentLiveId = null;
        selectedStream = null;
        placeholder.style.display = "block";
        updateViewerFeeds();
      }
    }

    socket.on("peer-left", ({ id }) => {
      if (viewers[id]) {
        const v = viewers[id];
        v.pc.close();
        delete viewers[id];
        return;
      }
      removePeer(id);
    });

    socket.on("camera-left", ({ id }) => {
      if (viewers[id]) {
        const v = viewers[id];
        v.pc.close();
        delete viewers[id];
        return;
      }
      removePeer(id);
    });

    /* ===== CAMERA ROTATION (MANUAL) ===== */
    socket.on("camera-rotate", ({ from, rotation }) => {
      rotations[from] = rotation;
      const p = peers[from];
      if (!p) return;

      const v = p.slot.querySelector("video");
      if (v) v.style.transform = `rotate(${rotation}deg)`;
    });

    /* ===== CREATE CAMERA PEER ===== */
    let cameraCount = 0;
    let turnConfig = null;

    async function getTurnConfig() {
      if (turnConfig) return turnConfig;
      try {
        const res = await fetch("/api/turn-credentials");
        turnConfig = await res.json();
        return turnConfig;
      } catch (e) {
        console.error("Failed to fetch TURN config:", e);
        return { iceServers: [{ urls: "stun:stun.cloudflare.com:3478" }] };
      }
    }

    /* ===== FILE RECEIVER ===== */
    const receivedRecordings = {}; // Store completed blobs by camera ID

    function handleDataMessage(id, data) {
      const p = peers[id];
      if (!p) return;

      // console.log(`üì® Msg from ${id}, type: ${typeof data}`, data);

      if (typeof data === "string") {
        try {
          const msg = JSON.parse(data);
          if (msg.type === "meta") {
            console.log(`üì• Receiving file from ${id}:`, msg);
            p.fileMeta = msg;
            p.fileBuffer = [];
            p.receivedSize = 0;

            // Show transfer UI
            const dash = document.getElementById("transferModal");
            if (dash.style.display !== "flex") dash.style.display = "flex";

            // Ensure Program Listing exists
            if (!document.getElementById("xfer_program")) {
              updateTransferUI("program", 100, true);
              const row = document.getElementById("xfer_program");
              if (row) row.querySelector(".name").innerText = "Director Program (Local)";
            }

            updateTransferUI(id, 0);
          } else if (msg.type === "end") {
            console.log(`‚úÖ File received from ${id}. Size: ${p.receivedSize}`);
            const blob = new Blob(p.fileBuffer, { type: p.fileMeta ? p.fileMeta.mime : "video/webm" });
            receivedRecordings[id] = blob;

            // Mark this camera as done in UI
            updateTransferUI(id, 100, true);

            // Check if all needed transfers are done
            checkTransfersComplete();
          }
        } catch (e) { console.error("Error parsing DC msg:", e); }
      } else {
        // Binary Chunk
        if (!p.fileMeta) console.warn("Received binary before meta from", id);

        // If data is Blob (shouldn't be with binaryType=arraybuffer, but safety check)
        if (data instanceof Blob) {
          console.warn("Received Blob instead of ArrayBuffer, converting...");
          // This is async, might break order. binaryType fix should prevent this.
          // data.arrayBuffer().then(buf => ... ) 
          // For now assume ArrayBuffer due to explicit setting
        }

        p.fileBuffer.push(data);
        p.receivedSize += data.byteLength || data.size || 0;

        if (p.fileMeta && p.fileMeta.size > 0) {
          const pct = Math.round((p.receivedSize / p.fileMeta.size) * 100);
          if (pct % 5 === 0 || pct === 100) updateTransferUI(id, pct);
        }
      }
    }

    function updateTransferUI(id, percent, done = false) {
      let row = document.getElementById(`xfer_${id}`);
      if (!row) {
        const list = document.getElementById("transferList");
        row = document.createElement("div");
        row.id = `xfer_${id}`;
        row.className = "file-item";
        row.style.display = "block"; // Override flex for block structure if needed, or keep flex
        // Actually file-item is flex, let's keep it but structure inner content
        row.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span class="name">Camera ${id.substring(0, 4)}</span>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span id="retry_${id}" style="display:none; color:var(--red); cursor:pointer; font-size:11px; text-decoration:underline;" onclick="retryTransfer('${id}')">Retry?</span>
                        <span class="pct" style="color: #94a3b8;">0%</span>
                    </div>
                </div>
                <div class="dash-progress">
                    <div class="progress-fill dash-fill"></div>
                </div>
            `;
        list.appendChild(row);
      }

      row.querySelector(".progress-fill").style.width = percent + "%";
      row.querySelector(".pct").innerText = percent + "%";
      if (done) {
        const retryBtn = document.getElementById(`retry_${id}`);
        if (retryBtn) retryBtn.style.display = "none";
        row.querySelector(".progress-fill").classList.add("done");
        row.querySelector(".progress-fill").style.background = "#10b981";
        row.querySelector(".pct").innerText = "Ready";
        row.querySelector(".pct").style.color = "#10b981";
      }
    }

    function retryTransfer(id) {
      if (id === 'program') return;
      console.log(`üîÑ Retrying transfer for: ${id}`);
      const row = document.getElementById(`xfer_${id}`);
      if (row) {
        row.querySelector(".pct").innerText = "Retrying...";
        row.querySelector(".pct").style.color = "var(--muted)";
        const retryBtn = document.getElementById(`retry_${id}`);
        if (retryBtn) retryBtn.style.display = "none";
      }
      socket.emit("control", { to: id, data: { type: "request-transfer" } });
    }

    async function checkTransfersComplete() {
      const activePeers = Object.keys(peers).filter(pid => peers[pid].stream);
      const missing = activePeers.filter(pid => !receivedRecordings[pid]);
      const allReceived = missing.length === 0;

      console.log(`Checking Transfers: Active = ${activePeers.length}, Received = ${Object.keys(receivedRecordings).length}, Missing = [${missing.join(', ')}]`);
    }

    async function createPeer(id, clientId = null) {
      console.log("üì° Director: Creating peer for", id, "ClientId:", clientId);
      const config = await getTurnConfig();
      const pc = new RTCPeerConnection(config);

      pc.addTransceiver("video", { direction: "recvonly" });
      pc.addTransceiver("audio", { direction: "recvonly" });

      peers[id] = { pc, stream: null, slot: null, name: "Camera " + id.substring(0, 4), clientId };

      const slot = document.createElement("div");
      slot.className = "camera-slot";

      const nameInput = document.createElement("input");
      nameInput.className = "camera-name";
      cameraCount += 1;
      nameInput.value = `Camera ${cameraCount} `;

      const actions = document.createElement("div");
      actions.className = "camera-actions";

      slot.appendChild(actions);
      slot.appendChild(nameInput);

      strip.appendChild(slot);

      peers[id].slot = slot;
      peers[id].name = nameInput.value;

      nameInput.oninput = () => {
        peers[id].name = nameInput.value.trim() || `Camera ${cameraCount} `;
      };

      pc.ontrack = e => {
        console.log("üé• Received track from:", id);
        if (peers[id].stream) return;

        const stream = e.streams[0] || new MediaStream([e.track]);
        peers[id].stream = stream;

        const v = document.createElement("video");
        v.autoplay = true;
        v.muted = true;
        v.playsInline = true;
        v.srcObject = stream;
        v.style.transform = `rotate(${rotations[id] || 0}deg)`;

        v.onloadedmetadata = () => {
          console.log("üé¨ Video metadata loaded for:", id);
          v.play().catch(err => console.error("Video play error:", err));
        };

        slot.appendChild(v);
        slot.onclick = () => setLiveCamera(id);

        if (recordingState !== "idle") {
          startCameraRecorder(id, stream);
        }
      };

      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("signal", { to: id, data: e.candidate });
        }
      };

      // Create Data Channel for File Transfer
      const dc = pc.createDataChannel("fileTransfer");
      dc.binaryType = "arraybuffer"; // Ensure we get ArrayBuffers, not Blobs

      peers[id].dc = dc;
      peers[id].fileBuffer = [];
      peers[id].fileMeta = null;
      peers[id].receivedSize = 0;

      dc.onopen = () => console.log(`‚úÖ Data Channel Open with ${id} `);
      dc.onmessage = (event) => handleDataMessage(id, event.data);

      pc.createOffer()
        .then(o => pc.setLocalDescription(o))
        .then(() => {
          console.log("üì° Director: Sending offer to camera", id);
          socket.emit("signal", { to: id, data: pc.localDescription });
        })
        .catch(err => console.error("Offer error:", err));
    }

    function setLiveCamera(id) {
      if (!id || !peers[id] || !peers[id].stream) {
        console.warn("‚ö†Ô∏è Cannot set live: No stream for", id);
        return;
      }
      activeCameraId = id; // Unify state
      currentLiveId = id;
      selectedStream = peers[id].stream;

      // Update EDL if recording ISO
      if (recordingState === "recording") {
        isoEdl.push({
          timestamp: Date.now() - recordStartTime,
          camId: id
        });
      }

      document.querySelectorAll(".camera-slot").forEach(s => s.classList.remove("active", "live"));
      if (peers[id].slot) peers[id].slot.classList.add("live", "active");

      Object.keys(peers).forEach(peerId => {
        socket.emit("control", {
          to: peerId,
          data: {
            type: "live",
            on: peerId === id,
            name: peers[peerId] ? peers[peerId].name : "Camera"
          }
        });
      });

      if (placeholder) placeholder.style.setProperty("display", "none", "important");
      updateViewerFeeds();
      startDrawLoop();
    }

    /* ===== VIEWERS ===== */
    async function createViewerPeer(id) {
      console.log("üì° Director: Creating peer for viewer", id);
      const track = getViewerTrack();
      if (!track) {
        console.warn("‚ö†Ô∏è Director: No track available for viewer!");
        return;
      }

      const config = await getTurnConfig();
      const pc = new RTCPeerConnection(config);

      const stream = new MediaStream([track]);
      const sender = pc.addTrack(track, stream);
      viewers[id] = { pc, sender };

      pc.onicecandidate = e => {
        if (e.candidate) {
          socket.emit("signal", { to: id, data: e.candidate });
        }
      };

      pc.createOffer()
        .then(o => pc.setLocalDescription(o))
        .then(() => {
          console.log("üì° Director: Sending offer to viewer", id);
          socket.emit("signal", { to: id, data: pc.localDescription });
        })
        .catch(err => console.error("Offer error:", err));
    }

    function queueOrCreateViewer(id) {
      createViewerPeer(id);
    }

    function flushPendingViewers() {
      // No-op now as we always have a program track
    }

    function updateViewerFeeds() {
      const track = getViewerTrack();
      if (!track) return;
      Object.values(viewers).forEach(v => {
        if (v.sender) {
          v.sender.replaceTrack(track).catch(err => console.error("replaceTrack error:", err));
        }
      });
    }

    function getViewerTrack() {
      // ALWAYS use programStream (canvas) for viewers for maximum stability.
      // This ensures viewers don't experience disconnects when cameras swap.
      return programStream.getVideoTracks()[0];
    }

    /* ===== PROGRAM CANVAS DRAW ===== */
    function startDrawLoop() {
      if (drawLoopRunning) return;
      drawLoopRunning = true;

      const draw = () => {
        const w = programCanvas.width;
        const h = programCanvas.height;

        programCtx.fillStyle = "#000";
        programCtx.fillRect(0, 0, w, h);

        if (currentLiveId && peers[currentLiveId]) {
          const videoEl = peers[currentLiveId].slot.querySelector("video");

          if (videoEl && videoEl.readyState >= 2) {
            const vw = videoEl.videoWidth;
            const vh = videoEl.videoHeight;

            if (vw > 0 && vh > 0) {
              const scale = Math.min(w / vw, h / vh);
              const dw = vw * scale;
              const dh = vh * scale;
              const rot = rotations[currentLiveId] || 0;

              programCtx.save();
              programCtx.translate(w / 2, h / 2);
              programCtx.rotate((rot * Math.PI) / 180);
              programCtx.drawImage(videoEl, -dw / 2, -dh / 2, dw, dh);
              programCtx.restore();
            }
          }
        }

        // Use requestAnimationFrame for smoothness, 
        // but also a setTimeout fallback so it keeps ticking in background tabs
        if (document.hidden) {
          setTimeout(draw, 100); // Lower rate when hidden to save CPU but stay "alive"
        } else {
          requestAnimationFrame(draw);
        }
      };

      requestAnimationFrame(draw);
    }
    startDrawLoop();

    /* ===== RECORDING UI ===== */
    // ISO STATE
    let isoSessionId = null;
    let isoEdl = []; // [{ timestamp, camId }]
    /* uploadedCameras removed - moved to downloads.html */

    const recordBar = document.getElementById("recordBar");
    const recordTimer = document.getElementById("recordTimer");
    const recordStatus = document.getElementById("recordStatus");
    const recordBtn = document.getElementById("recordBtn");
    const recIcon = document.querySelector(".rec-icon");
    const stopIcon = document.querySelector(".stop-icon");
    // const isoToggle = document.getElementById("isoToggle"); // REMOVED
    const qrBtn = document.getElementById("qrBtn");

    recordBtn.onclick = toggleRecord;

    // Fix: Attach QR button listener
    if (qrBtn) qrBtn.onclick = openQr;

    // ISO Toggle logic removed

    function toggleRecord() {
      try {
        console.log("Record button clicked. State:", recordingState);
        if (recordingState === "idle") startRecording();
        else stopRecordingRequest(); // Changed to Request
      } catch (e) {
        console.error("Critical error in toggleRecord:", e);
        window.alert("An unexpected error occurred: " + e.message);
      }
    }

    /* ===== ISO UPLOAD HANDLER REMOVED - MOVED TO downloads.html ===== */

    socket.on("render-progress", ({ progress, status }) => {
      // Keep legacy progress panel for non-ISO tasks if needed, 
      // but ISO progress is now in downloads.html
      const bar = document.getElementById("renderProgressPanel");
      const fill = document.getElementById("renderProgressFill");
      const text = document.getElementById("renderStatusText");
      if (!bar) return;

      if (progress < 0) {
        if (text) text.innerText = "Error: " + status;
        if (fill) fill.style.background = "#ef4444";
        setTimeout(() => { bar.style.display = "none"; }, 5000);
        return;
      }

      bar.style.display = "flex";
      if (fill) fill.style.width = progress + "%";
      if (text) text.innerText = status + " (" + progress + "%)";

      if (progress >= 100) {
        setTimeout(() => { bar.style.display = "none"; }, 3000);
      }
    });

    // switchCamera removed - using setLiveCamera directly

    function startRecording() {
      console.log("Attempting to start recording (Dual Mode)...");

      const hasCameras = Object.keys(peers).length > 0;
      const vidElem = document.getElementById("mainVideo");
      // const hasStream = vidElem && !!vidElem.srcObject; // Checking stream not strictly required for ISO start

      recordingState = "recording";
      recordBtn.classList.add("active");
      recIcon.style.display = "none";
      stopIcon.style.display = "block";
      recordBar.style.display = "flex";
      recordStatus.textContent = "REC";
      recordStartTime = Date.now();

      // 1. START ISO (Server-Side)
      isoSessionId = `session_${Date.now()} `;
      isoEdl = [];

      // Log initial camera or First available if none selected
      if (activeCameraId) {
        isoEdl.push({ timestamp: 0, camId: activeCameraId });
      } else if (hasCameras) {
        // Auto-select first camera for EDL reference
        const firstCam = Object.keys(peers)[0];
        setLiveCamera(firstCam); // Fix: use unified state setter
        isoEdl.push({ timestamp: 0, camId: firstCam });
      }

      socket.emit("start-iso", { room: streamId, sessionId: isoSessionId });

      // 2. START LOCAL (Browser-Side)
      const stream = vidElem.srcObject;

      // Fix: Reset programRecorder completely
      if (programRecorder) {
        try { programRecorder.stop(); } catch (e) { }
        programRecorder = null;
      }

      programChunks.length = 0; // Clear global array
      programRecorder = createRecorder(stream, programChunks);
      programRecorder.chunks = programChunks;
      programRecorder.start();

      // Fix: Clear and restart camera recorders
      Object.keys(cameraRecorders).forEach(id => {
        try { cameraRecorders[id].recorder.stop(); } catch (e) { }
        delete cameraRecorders[id];
      });

      Object.keys(peers).forEach(id => {
        if (peers[id].stream) startCameraRecorder(id, peers[id].stream);
      });

      // Clear previous recordings
      Object.keys(receivedRecordings).forEach(key => delete receivedRecordings[key]);

      tickTimer();
    }

    // PAUSE/RESUME REMOVED - STRICT START/STOP
    function pauseRecording() { }
    function resumeRecording() { }

    async function stopRecordingRequest() {
      if (recordingState === "idle") return;
      // Skip modal, go straight to finalize
      await stopAndFinalize('all');
    }

    function closeStopModal() {
      document.getElementById("stopModal").style.display = "none";
    }

    function showQualityOptions() {
      closeStopModal();
      document.getElementById("qualitySubModal").style.display = "flex";
    }

    function closeQualitySubModal() {
      document.getElementById("qualitySubModal").style.display = "none";
      document.getElementById("stopModal").style.display = "flex";
    }

    async function handleQualitySave(mode) {
      document.getElementById("qualitySubModal").style.display = "none";
      await stopAndFinalize(mode); // 'all' or 'program'
    }

    async function confirmInstantSave() {
      closeStopModal();
      await stopAndFinalize("instant");
    }

    async function confirmBothSave() {
      closeStopModal();
      await stopAndFinalize("both");
    }

    async function stopAndFinalize(mode) {
      console.log("Finalizing Recording (Selection Mode)...");

      // 1. UI FEEDBACK - Skipped to prevent flicker
      // const dash = document.getElementById("transferModal");
      // if (dash) dash.style.display = "flex";

      try {
        console.log("üõë Stopping session...");

        // 2. STOP RECORDING STATE (Local)
        recordingState = "idle";
        clearInterval(recordTimerInt);
        const recBtn = document.getElementById("recordBtn");
        if (recBtn) recBtn.classList.remove("recording", "active");

        // Update Icons
        document.querySelector(".rec-icon").style.display = "block";
        document.querySelector(".stop-icon").style.display = "none";
        document.getElementById("recordBar").style.display = "none";
        document.getElementById("recordTimer").innerText = "00:00:00";

        // 3. STOP LOCAL RECORDER INSTANCES
        const stopPromises = [];
        if (programRecorder) stopPromises.push(stopRecorder(programRecorder));
        Object.values(cameraRecorders).forEach(r => stopPromises.push(stopRecorder(r.recorder)));

        await Promise.all(stopPromises);

        // 4. SHOW DASHBOARD
        const dash = document.getElementById("transferModal");
        if (dash) dash.style.display = "flex";

        // Populate Instant List with local program
        const list = document.getElementById("instantList");
        if (list) {
          list.innerHTML = "";
          if (programChunks.length) {
            addToInstantList("Director Program (Local)", "SAVED");
          }
        }

        // 5. SIGNAL SAVE TO CAMERAS (Triggers P2P)
        Object.keys(peers).forEach(id => {
          socket.emit("control", { to: id, data: { type: "stop-iso", save: "hold" } });
        });

        console.log("‚è≥ Stop signals sent. Showing Selection Modal...");
        showDownloadSelectionModal();

      } catch (e) {
        console.error("CRITICAL ERROR in stopAndFinalize:", e);
        alert("Error finalizing session: " + e.message);
      }
    }


    function showDownloadSelectionModal() {
      // Show Transfer Modal as container for selection
      document.getElementById("transferModal").style.display = "flex";

      const container = document.getElementById("completePhase");
      if (!container) return;

      // Show render phase container but empty
      document.getElementById("renderPhase").style.display = "block";

      // Inject Selection UI
      const timestamp = formatDate(Date.now());

      let html = `
            <div style="max-width: 600px; margin: 0 auto; background: #161922; border: 1px solid #262b3d; border-radius: 12px; padding: 24px;">
                <h2 style="margin-top:0; color:white; display:flex; align-items:center; gap:10px;">
                    Download Selection
                    <span style="font-size:12px; background:#334155; padding:2px 8px; border-radius:12px; color:#cbd5e1;">${timestamp}</span>
                </h2>
                <p style="color:#94a3b8; font-size:14px; margin-bottom:20px;">Select the files you want to process and download.</p>
                
                <div id="selectionList" style="display:flex; flex-direction:column; gap:12px; max-height:400px; overflow-y:auto; margin-bottom:24px;">
                    
                    <div class="selection-item" style="background:#0f1115; padding:12px; border-radius:8px; border:1px solid #334155;">
                        <label style="display:flex; align-items:center; cursor:pointer; font-weight:600;">
                            <input type="checkbox" id="sel_final_mix" checked style="accent-color:#3b82f6; width:18px; height:18px; margin-right:12px;">
                            Final Mix (Stitched Program)
                        </label>
                        <div style="margin-top:8px; margin-left:30px; display:flex; gap:15px; font-size:13px; color:#cbd5e1;">
                            <label><input type="radio" name="fmt_final_mix" value="mp4" checked> MP4 (Compatibility)</label>
                            <label><input type="radio" name="fmt_final_mix" value="webm"> WebM (Fast)</label>
                        </div>
                    </div>

                    <div class="selection-item" style="background:#0f1115; padding:12px; border-radius:8px; border:1px solid #334155;">
                        <label style="display:flex; align-items:center; cursor:pointer;">
                            <input type="checkbox" id="sel_program" style="accent-color:#3b82f6; width:18px; height:18px; margin-right:12px;">
                            Director Program (Local Mirror)
                        </label>
                         <div style="margin-top:8px; margin-left:30px; display:flex; gap:15px; font-size:13px; color:#cbd5e1;">
                            <label><input type="radio" name="fmt_program" value="mp4"> MP4</label>
                            <label><input type="radio" name="fmt_program" value="webm" checked> WebM (Instant)</label>
                        </div>
                    </div>
        `;

      Object.keys(peers).forEach(id => {
        const name = peers[id].name || `Camera ${id.substring(0, 4)}`;
        html += `
                    <div class="selection-item" style="background:#0f1115; padding:12px; border-radius:8px; border:1px solid #334155;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                            <span style="color:white; font-weight:500;">${name}</span>
                            <div style="display:flex; gap:8px;">
                                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#94a3b8;">
                                    <input type="checkbox" id="sel_iso_${id}" checked style="accent-color:#3b82f6;"> ISO Source
                                </label>
                                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#94a3b8;">
                                    <input type="checkbox" id="sel_mirror_${id}" style="accent-color:#3b82f6;"> Mirror
                                </label>
                            </div>
                        </div>
                        <div style="margin-left:0; display:flex; gap:15px; font-size:12px; color:#cbd5e1; border-top:1px solid #262b3d; padding-top:8px;">
                            <span style="color:#64748b;">Convert To:</span>
                            <label><input type="radio" name="fmt_iso_${id}" value="mp4" checked> MP4</label>
                            <label><input type="radio" name="fmt_iso_${id}" value="webm"> WebM</label>
                        </div>
                    </div>
                `;
      });

      html += `
                </div>
                <div id="downloadButtons" style="display:flex; flex-direction:column; gap:12px;">
                    <button class="btn-premium" onclick="processSelectedDownloads()" style="width:100%; height:48px; font-size:16px; justify-content:center;">
                        Start Processing & Download
                    </button>
                    <button class="dash-btn" onclick="closeStopModal()" style="width:100%; border-color:#334155; color:#94a3b8;">
                        Back to Recording
                    </button>
                </div>
            </div>
        `;

      // Override the Render Phase/Progress panel deeply
      const renderPanel = document.getElementById("renderPhase");
      renderPanel.innerHTML = html;
      renderPanel.style.display = "block";

      // Hide complete phase if returning
      document.getElementById("completePhase").style.display = "none";
    }

    function addToInstantList(name, status, id = null) {
      const list = document.getElementById("instantList");
      const div = document.createElement("div");
      div.className = "file-item";
      if (id) div.id = id;

      div.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span class="name">${name}</span> 
                    <div style="display:flex; align-items:center;">
                        <span class="status-badge processing">${status}</span>
                    </div>
                </div>
                <div class="dash-progress" style="display:none;">
                    <div class="dash-fill" style="width: 0%"></div>
                </div>
            `;
      list.appendChild(div);
      return div;
    }

    function updateInstantStatus(id, text, type = "processing", progress = -1) {
      const el = document.getElementById(id);
      if (!el) return;

      const badge = el.querySelector(".status-badge");
      if (badge) {
        badge.innerText = text;
        badge.className = `status-badge ${type}`;
      }

      const progBar = el.querySelector(".dash-progress");
      const progFill = el.querySelector(".dash-fill");

      if (progress >= 0 && progBar && progFill) {
        progBar.style.display = "block";
        progFill.style.width = `${progress}%`;
      } else if (progress < 0 && progBar) {
        progBar.style.display = "none";
      }
    }

    function markInstantComplete() {
      const badges = document.querySelectorAll("#instantList .status-badge");
      badges.forEach(b => {
        b.className = "status-badge success";
        b.innerText = "SAVED";
      });
    }


    function tickTimer() {
      clearInterval(recordTimerInt);
      recordTimerInt = setInterval(() => {
        const elapsed = Math.max(0, Date.now() - recordStartTime);
        recordTimer.textContent = formatTime(elapsed / 1000);
      }, 500);
    }

    function createRecorder(stream, chunks) {
      const type = getSupportedMime();
      const rec = new MediaRecorder(stream, type ? { mimeType: type } : undefined);
      rec.ondataavailable = e => {
        if (e.data && e.data.size > 0) {
          chunks.push(e.data);
          // console.log(`Captured chunk: ${ e.data.size } bytes`);
        }
      };
      return rec;
    }

    function stopRecorder(rec) {
      return new Promise(resolve => {
        if (!rec || rec.state === "inactive") return resolve();
        let timeout = setTimeout(() => {
          console.warn("Stop recorder timed out");
          resolve();
        }, 1000);
        rec.onstop = () => {
          clearTimeout(timeout);
          resolve();
        };
        try {
          rec.stop();
        } catch (e) {
          console.warn("Error stopping recorder:", e);
          clearTimeout(timeout);
          resolve();
        }
      });
    }

    function getSupportedMime() {
      const types = [
        "video/webm;codecs=vp9,opus",
        "video/webm;codecs=vp8,opus",
        "video/webm"
      ];
      return types.find(t => MediaRecorder.isTypeSupported(t));
    }

    function startCameraRecorder(id, stream) {
      if (cameraRecorders[id]) return;
      const chunks = [];
      const rec = createRecorder(stream, chunks);
      cameraRecorders[id] = { recorder: rec, chunks };
      rec.start();
    }

    function sanitizeName(str) {
      return (str || "").toString().trim().replace(/\s+/g, "_").replace(/[^a-zA-Z0-9_\-]/g, "");
    }

    function formatDate(ts) {
      const d = new Date(ts);
      const pad = n => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
    }

    function formatTime(sec) {
      const s = Math.floor(sec);
      const h = String(Math.floor(s / 3600)).padStart(2, "0");
      const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
      const r = String(s % 60).padStart(2, "0");
      return `${h}:${m}:${r}`;
    }

    function parseTime(t) {
      const [h, m, s] = t.split(":").map(Number);
      return h * 3600 + m * 60 + s;
    }

    /* ===== MP4 CONVERSION ===== */
    let ffmpegInstance = null;
    let ffmpegRef = null; // Store the ffmpeg object
    let fetchFileRef = null;

    async function ensureFFmpeg() {
      if (ffmpegInstance) return { ffmpeg: ffmpegRef, fetchFile: fetchFileRef };

      console.log("Loading FFmpeg.wasm v0.12...");
      const { FFmpeg } = window.FFmpegWASM;
      const { fetchFile } = window.FFmpegUtil;

      const ffmpeg = new FFmpeg();

      ffmpeg.on("log", ({ message }) => {
        // console.log("FFmpeg Log:", message);
      });

      // Load with local files
      await ffmpeg.load({
        coreURL: '/lib/ffmpeg/ffmpeg-core.js',
        wasmURL: '/lib/ffmpeg/ffmpeg-core.wasm',
        workerLoadURL: '/lib/ffmpeg/814.ffmpeg.js' // Explicitly load the worker chunk from valid origin
      });

      ffmpegRef = ffmpeg;
      fetchFileRef = fetchFile;
      ffmpegInstance = true;
      return { ffmpeg, fetchFile };
    }

    async function convertToMp4(blob, baseName) {
      // This legacy function might not be used in the new flow but updating just in case
      const { ffmpeg, fetchFile } = await ensureFFmpeg();
      const input = `${baseName}.webm`;
      const output = `${baseName}.mp4`;

      await ffmpeg.writeFile(input, await fetchFile(blob));
      await ffmpeg.exec(["-i", input, "-c:v", "libx264", "-preset", "veryfast", "-c:a", "aac", output]);
      const data = await ffmpeg.readFile(output);

      // Cleanup not strictly necessary here if we do it in batch, but good practice
      await ffmpeg.deleteFile(input);
      await ffmpeg.deleteFile(output);

      return new Blob([data.buffer], { type: "video/mp4" });
    }



    function enableInstantDownload(id, blob, filename) {
      const el = document.getElementById(id);
      const badge = el.querySelector(".status-badge");
      if (badge) {
        badge.className = "status-badge success";
        badge.innerText = "READY";
      }

      // Remove existing button if any
      const existingBtn = el.querySelector(".instant-dl-btn");
      if (existingBtn) existingBtn.remove();

      const btn = document.createElement("a");
      btn.className = "instant-dl-btn";
      btn.innerText = "Download";
      btn.style.marginLeft = "10px";
      btn.style.background = "#3b82f6";
      btn.style.color = "white";
      btn.style.padding = "4px 10px";
      btn.style.borderRadius = "4px";
      btn.style.textDecoration = "none";
      btn.style.fontSize = "12px";
      btn.style.cursor = "pointer";
      btn.style.fontWeight = "600";

      const url = URL.createObjectURL(blob);
      btn.href = url;
      btn.download = filename;

      // Append to the inner wrapper (where status badge is)
      const wrapper = el.querySelector("div > div");
      if (wrapper) wrapper.appendChild(btn);
    }



    /* ===== QR ===== */
    function openQr() {
      const modal = document.getElementById("qrModal");
      const box = document.getElementById("qrCode");
      const linkBox = document.getElementById("qrLink");
      box.innerHTML = "";

      const url = `https://courtstream.live/camera-live.html?stream=${encodeURIComponent(streamId)}&name=${encodeURIComponent(streamLabel || "")}`;
      new QRCode(box, {
        text: url,
        width: 200,
        height: 200,
        colorDark: "#ffffff",
        colorLight: "#161922"
      });
      linkBox.textContent = url;
      modal.style.display = "flex";
    }

    function closeQr() {
      document.getElementById("qrModal").style.display = "none";
    }

    async function goToPlayback() {
      if (recordingState !== "idle") {
        if (await confirm("Recording in progress. Stop and save to Downloads before going to Playback?")) {
          try {
            await stopAndFinalize('all');
            // Allow time for downloads to initiate
            setTimeout(() => location.href = "playback.html", 1500);
          } catch (e) {
            console.error(e);
            alert("Error stopping recording: " + e);
          }
        }
      } else {
        location.href = "playback.html";
      }
    }

    // Alias for compatibility
    async function stopRecording() {
      return stopAndFinalize('all');
    }

    /* ===== SIGNAL ===== */
    socket.on("signal", async ({ from, data }) => {
      const p = peers[from];
      const v = viewers[from];
      if (!p && !v) {
        console.log("üì° Director: Signal from unknown peer", from);
        return;
      }

      try {
        if (data.type) {
          console.log(`üì° Director: Received ${data.type} from`, from);
          if (p) await p.pc.setRemoteDescription(new RTCSessionDescription(data));
          if (v) await v.pc.setRemoteDescription(new RTCSessionDescription(data));
        } else {
          // Robust candidate handling
          let cand = null;
          if (data.candidate !== undefined && typeof data.candidate === 'string') {
            cand = data;
          } else if (data.candidate && data.candidate.candidate !== undefined) {
            cand = data.candidate;
          } else if (data.sdpMid !== undefined) {
            cand = data;
          }

          if (cand) {
            console.log("‚úÖ Director: Adding ICE candidate from", from);
            if (p) await p.pc.addIceCandidate(new RTCIceCandidate(cand));
            if (v) await v.pc.addIceCandidate(new RTCIceCandidate(cand));
          }
        }
      } catch (e) {
        console.warn("Signal error:", e);
      }
    });
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    async function processSelectedDownloads() {
      const btn = document.querySelector("#renderPhase button");
      if (btn) { btn.disabled = true; btn.innerText = "Initializing Transfer..."; }

      // Gather Selections
      const ops = {
        final: document.getElementById('sel_final_mix')?.checked ?
          document.querySelector('input[name="fmt_final_mix"]:checked').value : null,
        program: document.getElementById('sel_program')?.checked ?
          document.querySelector('input[name="fmt_program"]:checked').value : null,
        isos: {},
        mirrors: {}
      };

      const activeCamIds = Object.keys(peers);
      const camerasToTransfer = new Set();

      // Determine which cameras need to transfer
      if (ops.final) {
        // Final Mix needs ALL active cameras
        activeCamIds.forEach(id => camerasToTransfer.add(id));
      }

      Object.keys(peers).forEach(id => {
        if (document.getElementById(`sel_iso_${id}`)?.checked) {
          ops.isos[id] = document.querySelector(`input[name="fmt_iso_${id}"]:checked`).value;
          camerasToTransfer.add(id);
        }
        if (document.getElementById(`sel_mirror_${id}`)?.checked) {
          ops.mirrors[id] = document.querySelector(`input[name="fmt_mirror_${id}"]:checked`).value;
        }
      });

      // 1. REQUEST TRANSFERS
      const missing = Array.from(camerasToTransfer).filter(id => !receivedRecordings[id]);
      if (missing.length > 0) {
        console.log("Requesting transfers for:", missing);

        // Populate Transfer List ONLY with what we need
        const dash = document.getElementById("transferModal");
        const tList = document.getElementById("transferList");
        if (tList) {
          tList.innerHTML = "";
          missing.forEach(id => {
            const name = peers[id]?.name || `Camera ${id.substring(0, 4)}`;
            const row = document.createElement("div");
            row.id = `xfer_${id}`;
            row.className = "file-item";
            row.innerHTML = `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                        <span class="name">${name}</span>
                        <span class="pct" style="color: #94a3b8;">0%</span>
                    </div>
                    <div class="dash-progress">
                        <div class="progress-fill dash-fill" style="width: 0%"></div>
                    </div>
                `;
            tList.appendChild(row);
          });
        }

        missing.forEach(id => {
          socket.emit("control", { to: id, data: { type: "request-transfer" } });
        });

        // Wait loop
        if (btn) btn.innerText = "Waiting for Camera Files...";
        await waitForTransfers(camerasToTransfer);

      }

      // UI Helpers
      const updateStatus = (pct, msg) => {
        if (btn) btn.innerText = `${msg} (${pct}%)`;
      };

      try {
        updateStatus(0, "Loading Engine");
        const { ffmpeg, fetchFile } = await ensureFFmpeg();

        // Track Transcoded Files
        const memFiles = {};

        // ===========================
        // 3. PREPARE ISO INPUTS
        // ===========================
        const needsIsoProcessing = ops.final || Object.values(ops.isos).includes('mp4');

        if (needsIsoProcessing) {
          const requiredIds = Array.from(camerasToTransfer);
          for (let i = 0; i < requiredIds.length; i++) {
            const id = requiredIds[i];
            const blob = receivedRecordings[id];
            if (!blob) continue;

            const name = `iso_${id}.webm`;
            updateStatus(10, `Reading Camera ${i + 1}`);
            await ffmpeg.writeFile(name, await fetchFile(blob));
            memFiles[`iso_${id}_webm`] = name;
          }
        }

        // ===========================
        // 4. GENERATE FINAL MIX
        // ===========================
        if (ops.final) {
          const ext = ops.final === 'webm' ? 'webm' : 'mp4';
          const vCodec = ext === 'mp4' ? ["-c:v", "libx264", "-preset", "ultrafast", "-crf", "23"] : ["-c:v", "libvpx", "-deadline", "realtime", "-b:v", "2M"];
          const aCodec = ext === 'mp4' ? ["-c:a", "aac", "-b:a", "128k"] : ["-c:a", "libvorbis"];

          // A. Ensure all required source files are in FFmpeg memory
          let usedFallback = false;
          for (let i = 0; i < camerasToTransfer.size; i++) {
            const id = Array.from(camerasToTransfer)[i];
            if (!memFiles[`iso_${id}_webm`]) {
              let blob = receivedRecordings[id];

              // FALLBACK LOGIC
              if (!blob && cameraRecorders[id] && cameraRecorders[id].chunks.length) {
                console.warn(`‚ö†Ô∏è Using local mirror fallback for camera ${id}`);
                blob = new Blob(cameraRecorders[id].chunks, { type: "video/webm" });
                usedFallback = true;
              }

              if (blob) {
                const name = `iso_${id}.webm`;
                await ffmpeg.writeFile(name, await fetchFile(blob));
                memFiles[`iso_${id}_webm`] = name;
              }
            }
          }

          if (usedFallback) {
            const warn = document.createElement("div");
            warn.style.padding = "8px";
            warn.style.marginTop = "10px";
            warn.style.background = "rgba(234, 179, 8, 0.1)";
            warn.style.border = "1px solid rgba(234, 179, 8, 0.2)";
            warn.style.borderRadius = "8px";
            warn.style.color = "#eab308";
            warn.style.fontSize = "12px";
            warn.innerText = "‚ö†Ô∏è Some segments using local mirror fallback due to connection issues.";
            document.getElementById("downloadButtons").appendChild(warn);
          }

          // B. Process Cuts with Re-encoding (Fixes Glitches)
          updateStatus(40, `Processing Cuts (${ext.toUpperCase()})`);
          const segments = [];
          for (let i = 0; i < isoEdl.length; i++) {
            const cut = isoEdl[i];
            const nextCut = isoEdl[i + 1];
            let duration = nextCut ? (nextCut.timestamp - cut.timestamp) / 1000 : null;

            let inputFile = memFiles[`iso_${cut.camId}_webm`];
            if (!inputFile) continue;

            const segName = `seg_${i}.${ext}`;
            // Input seeking (-ss before -i) is faster and more accurate for re-encoding
            const args = ["-ss", String(cut.timestamp / 1000)];
            args.push("-i", inputFile);
            if (duration) args.push("-t", String(duration));

            // NORMALIZATION: Force 720p, 30fps, 44.1kHz audio to ensure seamless stitching
            args.push("-vf", "scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2,setsar=1,format=yuv420p");
            args.push("-r", "30");
            args.push("-ar", "44100");

            args.push(...vCodec, ...aCodec, segName);

            updateStatus(40 + Math.round((i / isoEdl.length) * 20), `Cutting Segment ${i + 1}/${isoEdl.length}`);
            await ffmpeg.exec(args);
            segments.push(segName);
          }

          // C. Stitch
          if (segments.length > 0) {
            updateStatus(70, "Stitching Mix");
            await ffmpeg.writeFile("list.txt", segments.map(s => `file '${s}'`).join("\n"));
            const finalName = `final_mix.${ext}`;
            await ffmpeg.exec(["-f", "concat", "-safe", "0", "-i", "list.txt", "-c", "copy", finalName]);

            // D. Download Final
            const timestamp = formatDate(Date.now());
            const finalData = await ffmpeg.readFile(finalName);
            const finalMime = ext === 'mp4' ? "video/mp4" : "video/webm";
            downloadBlob(new Blob([finalData.buffer], { type: finalMime }), `courtstream_final_${timestamp}.${ext}`);

            // Cleanup segments
            for (const seg of segments) await ffmpeg.deleteFile(seg);
            await ffmpeg.deleteFile(finalName);
            await ffmpeg.deleteFile("list.txt");
          }
        }

        // ===========================
        // 5. PROCESS INDIVIDUAL ISOs
        // ===========================
        const isoIds = Object.keys(ops.isos);
        for (const id of isoIds) {
          const fmt = ops.isos[id];
          const timestamp = formatDate(Date.now());
          if (fmt === 'webm') {
            if (receivedRecordings[id]) downloadBlob(receivedRecordings[id], `camera_${id}_${timestamp}.webm`);
          } else if (fmt === 'mp4') {
            updateStatus(80, `Converting ISO ${id} to MP4`);
            if (!memFiles[`iso_${id}_webm`]) {
              await ffmpeg.writeFile(`iso_${id}.webm`, await fetchFile(receivedRecordings[id]));
            }
            await ffmpeg.exec(["-i", `iso_${id}.webm`, "-c:v", "libx264", "-preset", "ultrafast", "-c:a", "aac", `iso_${id}.mp4`]);
            const data = await ffmpeg.readFile(`iso_${id}.mp4`);
            downloadBlob(new Blob([data.buffer], { type: 'video/mp4' }), `camera_${id}_${timestamp}.mp4`);
            await ffmpeg.deleteFile(`iso_${id}.mp4`);
          }
        }

        // ===========================
        // 6. PROCESS MIRRORS (Local)
        // ===========================
        const mirrorIds = Object.keys(ops.mirrors);
        for (const id of mirrorIds) {
          const fmt = ops.mirrors[id];
          const rec = cameraRecorders[id];
          if (rec && rec.chunks.length) {
            const blob = new Blob(rec.chunks, { type: "video/webm" });
            const timestamp = formatDate(Date.now());
            const name = `mirror_${id}_${timestamp}`;

            if (fmt === 'webm') {
              downloadBlob(blob, name + ".webm");
            } else {
              updateStatus(80, `Converting Mirror ${id}`);
              await ffmpeg.writeFile("mirror_in.webm", await fetchFile(blob));
              await ffmpeg.exec(["-i", "mirror_in.webm", "-c:v", "libx264", "-preset", "ultrafast", "-c:a", "aac", "out_mirror.mp4"]);
              const data = await ffmpeg.readFile("out_mirror.mp4");
              downloadBlob(new Blob([data.buffer], { type: 'video/mp4' }), name + ".mp4");
              await ffmpeg.deleteFile("mirror_in.webm");
              await ffmpeg.deleteFile("out_mirror.mp4");
            }
          }
        }

        // ===========================
        // 7. PROCESS PROGRAM (Local)
        // ===========================
        if (ops.program && programChunks.length) {
          const blob = new Blob(programChunks, { type: "video/webm" });
          const timestamp = formatDate(Date.now());
          const name = `program_${timestamp}`;

          if (ops.program === 'webm') {
            downloadBlob(blob, name + ".webm");
          } else {
            updateStatus(90, "Converting Program");
            await ffmpeg.writeFile("prog_in.webm", await fetchFile(blob));
            await ffmpeg.exec(["-i", "prog_in.webm", "-c:v", "libx264", "-preset", "ultrafast", "-c:a", "aac", "out_prog.mp4"]);
            const data = await ffmpeg.readFile("out_prog.mp4");
            downloadBlob(new Blob([data.buffer], { type: 'video/mp4' }), name + ".mp4");
          }
        }

        updateStatus(100, "Done!");
        document.getElementById("completePhase").style.display = "block";
        if (btn) btn.innerText = "Processing Complete";

        // Add Re-render button
        if (!document.getElementById("rerenderBtn")) {
          const area = document.getElementById("downloadButtons");
          const reb = document.createElement("button");
          reb.id = "rerenderBtn";
          reb.className = "dash-btn";
          reb.style.marginTop = "16px";
          reb.style.width = "100%";
          reb.style.background = "transparent";
          reb.style.border = "1px dashed var(--border)";
          reb.innerText = "Re-render Again";
          reb.onclick = () => processSelectedDownloads(ops); // re-use ops
          area.appendChild(reb);
        }

      } catch (e) {
        console.error("Processing Error:", e);
        alert("Error processing files: " + e.message);
        if (btn) { btn.disabled = false; btn.innerText = "Retry"; }
      }
    }

    function waitForTransfers(requiredSet) {
      return new Promise(resolve => {
        const start = Date.now();
        const timeout = 20000; // 20s timeout
        const check = setInterval(() => {
          const missing = Array.from(requiredSet).filter(id => !receivedRecordings[id]);
          const elapsed = Date.now() - start;

          if (missing.length === 0 || elapsed > timeout) {
            clearInterval(check);
            if (missing.length > 0) {
              console.warn("‚ö†Ô∏è waitForTransfers timed out for:", missing);
              missing.forEach(id => {
                const retryBtn = document.getElementById(`retry_${id}`);
                if (retryBtn) retryBtn.style.display = "inline-block";
                const row = document.getElementById(`xfer_${id}`);
                if (row) {
                  row.querySelector(".pct").innerText = "Timed Out";
                  row.querySelector(".pct").style.color = "var(--red)";
                }
              });
            }
            resolve();
          }
        }, 500);
      });
    }

  </script>
  <script src="feedback.js"></script>
  <div id="renderProgressPanel"
    style="display:none; position:fixed; bottom:100px; left:50%; transform:translateX(-50%); width:320px; background:rgba(0,0,0,0.8); padding:16px; border-radius:12px; border:1px solid var(--border); z-index:200; flex-direction:column; gap:8px;">
    <div style="font-size:12px; font-weight:600; color:#94a3b8;" id="renderStatusText">Rendering Video...</div>
    <div style="height:8px; background:#1e293b; border-radius:4px; overflow:hidden;">
      <div id="renderProgressFill" style="width:0%; height:100%; background:#3b82f6; transition: width 0.3s ease;">
      </div>
    </div>
  </div>
</body>

</html>