<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Camera Live â€“ CourtStream</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ef4444' stroke-width='2'><circle cx='12' cy='12' r='10'/><path d='M9.5 8l6 4-6 4V8z' fill='white' stroke='none'/></svg>">

  <style>
    :root {
      --bg: #0f1115;
      --card: #161922;
      --border: #262b3d;
      --red: #b91c1c;
    }

    /* Feedback Button Override - Top Right */
    .feedback-fab {
      top: 24px !important;
      right: 24px !important;
      bottom: auto !important;
      left: auto !important;
    }

    .live-indicator {
      display: none;
      background: #ef4444;
      color: white;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 4px;
      margin-left: 8px;
      font-size: 11px;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #fff;
      font-family: system-ui;
    }

    .page {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
    }

    /* HEADER */
    .header {
      height: 56px;
      display: flex;
      align-items: center;
      padding: 0 16px;
      justify-content: center;
      position: relative;
    }

    .header-title {
      font-size: 15px;
      font-weight: 600;
      display: flex;
      align-items: center;
    }

    /* PREVIEW */
    .preview {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    video {
      width: 90vw;
      max-width: 420px;
      max-height: 100%;
      background: #000;
      border-radius: 18px;
      object-fit: contain;
      /* NO CROPPING */
      transition: transform .25s ease;
    }

    /* CONTROLS */
    .controls {
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 18px 0 24px;
    }

    .ctrl {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--card);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ctrl.off {
      background: var(--red);
      border-color: var(--red);
    }

    .ctrl.end {
      border-color: var(--red);
      background: rgba(185, 28, 28, 0.2);
    }

    .ctrl svg {
      width: 24px;
      height: 24px;
      fill: #fff;
    }

    /* Passcode Overlay */
    #passcodeOverlay {
      display: none;
      position: absolute;
      inset: 0;
      background: rgba(15, 17, 21, 0.95);
      z-index: 100;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 20px;
      text-align: center;
    }

    #passInput {
      background: var(--bg);
      border: 1px solid var(--border);
      color: #fff;
      padding: 12px;
      border-radius: 8px;
      width: 100%;
      max-width: 240px;
      text-align: center;
      font-size: 18px;
      letter-spacing: 4px;
      margin-bottom: 16px;
    }

    #joinBtn {
      padding: 10px 24px;
      background: #3b82f6;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      color: white;
      cursor: pointer;
    }

    /* UPLOAD PROGRESS */
    #uploadProgressOverlay {
      display: none;
      position: absolute;
      bottom: 100px;
      left: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      z-index: 50;
      flex-direction: column;
      gap: 8px;
    }

    .progress-bar {
      height: 6px;
      background: #1e293b;
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #3b82f6;
      width: 0%;
      transition: width 0.1s linear;
    }
  </style>
</head>

<body>

  <div class="page">

    <div class="header">
      <div class="header-title">
        <span id="streamNameDisplay">Camera Ready</span>
        <span id="liveBadge" class="live-indicator">LIVE</span>
      </div>
    </div>

    <div class="preview">
      <video id="video" autoplay muted playsinline></video>
    </div>

    <div class="controls">
      <!-- MIC -->
      <button id="micBtn" class="ctrl" onclick="toggleMic()">
        <svg viewBox="0 0 24 24">
          <path d="M12 14a3 3 0 003-3V5a3 3 0 10-6 0v6a3 3 0 003 3z" />
          <path d="M19 11a7 7 0 01-14 0" />
        </svg>
      </button>

      <!-- CAMERA -->
      <button id="camBtn" class="ctrl" onclick="toggleCam()">
        <svg viewBox="0 0 24 24">
          <path d="M17 10.5V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-3.5l4 4v-11l-4 4z" />
        </svg>
      </button>

      <!-- LEAVE -->
      <button class="ctrl end" onclick="leave()">
        <svg viewBox="0 0 24 24">
          <path d="M21 7.5l-3.5-2v4H10v3h7.5v4z" />
          <path d="M3 5h8v14H3z" />
        </svg>
      </button>
    </div>

    <!-- Upload Progress -->
    <div id="uploadProgressOverlay">
      <div style="font-size: 11px; font-weight: 600; color: #94a3b8;">Uploading High Quality Clip...</div>
      <div class="progress-bar">
        <div id="uploadProgressFill" class="progress-fill"></div>
      </div>
    </div>

  </div>

  <!-- Passcode Overlay -->
  <div id="passcodeOverlay">
    <h3 style="margin-top:0;">Secured Stream</h3>
    <p style="color:var(--muted);font-size:14px;margin-bottom:20px;">This stream requires a passcode for cameras to
      join.</p>
    <input type="password" id="passInput" placeholder="Enter Passcode">
    <button id="joinBtn">Join Stream</button>
    <div id="errorMsg" style="color:#ef4444;font-size:12px;margin-top:12px;display:none;">Invalid passcode. Please
      try again.</div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="feedback.js"></script>
  <script src="modal.js"></script>
  <script>
    /* ===== STATE ===== */
    const streamId = new URLSearchParams(location.search).get("stream");
    const streamName = new URLSearchParams(location.search).get("name");
    const video = document.getElementById("video");
    const micBtn = document.getElementById("micBtn");
    const camBtn = document.getElementById("camBtn");
    const streamTitle = document.getElementById("streamTitle"); // Note: removed from HTML but variable might be used? (Updated HTML uses streamNameDisplay)
    const liveBadge = document.getElementById("liveBadge");
    const overlay = document.getElementById("passcodeOverlay");
    const passInput = document.getElementById("passInput");
    const joinBtn = document.getElementById("joinBtn");
    const errorMsg = document.getElementById("errorMsg");

    let mediaStream;
    let videoSender;
    let micOn = true;
    let camOn = true;
    let facing = "environment";
    let directorId = null;
    let isLive = false;
    let videoDevices = [];
    let currentDeviceIndex = 0;
    let hasPickedDefault = false;
    let resolveCameraReady;
    const cameraReady = new Promise(r => { resolveCameraReady = r; });

    const pendingCandidates = []; // Buffer signals until remote description is set

    /* ===== WEBRTC ===== */
    let turnConfig = null;
    async function getTurnConfig() {
      if (turnConfig) return turnConfig;
      try {
        const res = await fetch("/api/turn-credentials");
        turnConfig = await res.json();
        return turnConfig;
      } catch (e) {
        console.error("Failed to fetch TURN config:", e);
        return { iceServers: [{ urls: "stun:stun.cloudflare.com:3478" }] };
      }
    }

    const socket = io();
    /* ===== CAMERA ===== */
    async function loadVideoDevices() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      videoDevices = devices.filter(d => d.kind === "videoinput");
      if (!videoDevices.length) return;

      const currentId = mediaStream && mediaStream.getVideoTracks()[0]
        ? mediaStream.getVideoTracks()[0].getSettings().deviceId
        : null;

      if (currentId) {
        const idx = videoDevices.findIndex(d => d.deviceId === currentId);
        if (idx >= 0) currentDeviceIndex = idx;
      }
    }

    function pickDefaultBackCamera() {
      if (!videoDevices.length) return;

      const backIndex = videoDevices.findIndex(d => {
        const label = (d.label || "").toLowerCase();
        return label.includes("back") || label.includes("rear") || label.includes("environment");
      });

      if (backIndex >= 0) {
        currentDeviceIndex = backIndex;
        facing = "environment";
      }
    }

    async function getStreamWithFallback() {
      const constraintsByPriority = [];

      if (videoDevices.length) {
        constraintsByPriority.push({
          video: { deviceId: { exact: videoDevices[currentDeviceIndex].deviceId } },
          audio: true
        });
      }

      constraintsByPriority.push({
        video: { facingMode: { exact: facing } },
        audio: true
      });

      constraintsByPriority.push({
        video: { facingMode: { ideal: facing } },
        audio: true
      });

      let lastError;
      for (const constraints of constraintsByPriority) {
        try {
          return await navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          lastError = err;
        }
      }

      throw lastError;
    }

    async function startCamera() {
      await loadVideoDevices();

      if (!hasPickedDefault) {
        pickDefaultBackCamera();
        hasPickedDefault = true;
      }

      const stream = await getStreamWithFallback();

      video.srcObject = stream;

      if (!mediaStream) {
        stream.getTracks().forEach(t => {
          const sender = pc.addTrack(t, stream);
          if (t.kind === "video") videoSender = sender;
        });
      } else {
        await videoSender.replaceTrack(stream.getVideoTracks()[0]);
        mediaStream.getTracks().forEach(t => t.stop());
      }

      mediaStream = stream;
      if (resolveCameraReady) {
        resolveCameraReady();
        resolveCameraReady = null;
      }
    }

    async function initWebRTC() {
      const config = await getTurnConfig();
      pc = new RTCPeerConnection(config);

      checkAccess();
      startCamera(); // Ensure camera starts after PC is initialized to add tracks

      pc.onicecandidate = e => {
        if (e.candidate) {
          if (directorId) {
            socket.emit("signal", { to: directorId, data: e.candidate });
          }
        }
      };

      socket.on("control", ({ from, data }) => {
        console.log("Control:", data);
        if (data && data.type === "live") {
          const isLive = data.on;
          document.getElementById("liveBadge").style.display = isLive ? "inline-block" : "none";

          // Show the name of the stream (which is the camera name set by director)
          if (data.name) {
            document.getElementById("streamNameDisplay").innerText = data.name;
          }

          // Optional: Visual feedback on the video border
          const v = document.querySelector("video");
          if (v) v.style.border = isLive ? "2px solid #ef4444" : "none";
        }
      });

      socket.on("signal", async ({ from, data }) => {
        if (!data) return;

        if (data.type === "offer") {
          console.log("ðŸ“¡ Camera: Received offer from director", from);
          directorId = from;
          await cameraReady;
          try {
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            socket.emit("signal", { to: from, data: pc.localDescription });

            // Flush buffered candidates
            while (pendingCandidates.length > 0) {
              const cand = pendingCandidates.shift();
              await pc.addIceCandidate(new RTCIceCandidate(cand)).catch(e => console.warn("ICE error:", e));
            }
          } catch (e) {
            console.error("Signaling error:", e);
          }
          return;
        }

        if (data.candidate) {
          if (pc.remoteDescription) {
            await pc.addIceCandidate(data).catch(e => console.warn("ICE error:", e));
          } else {
            pendingCandidates.push(data);
          }
        }
      });
    }
    initWebRTC();


    /* ===== ACTIONS ===== */
    function toggleMic() {
      micOn = !micOn;
      if (mediaStream) {
        mediaStream.getAudioTracks().forEach(t => (t.enabled = micOn));
      }
      micBtn.classList.toggle("off", !micOn);
    }

    function toggleCam() {
      camOn = !camOn;
      if (mediaStream) {
        mediaStream.getVideoTracks().forEach(t => (t.enabled = camOn));
      }
      camBtn.classList.toggle("off", !camOn);
    }

    async function leave() {
      if (await confirm("Stop Streaming?\n\nThis will end your session and take you back to the home page.", "destructive")) {
        location.href = 'index.html';
      }
    }

    /* ===== ORIENTATION ===== */
    const rotations = {};
    function applyOrientation() {
      const orient = window.orientation;
      let rot = 0;
      if (orient === 90) rot = -90;
      if (orient === -90) rot = 90;
      if (orient === 180) rot = 180;

      rotations[socket.id] = rot;
      socket.emit("camera-rotate", { room: streamId, rotation: rot });

      video.style.transform = isLive ? `scale(1.05) rotate(${rot}deg)` : `rotate(${rot}deg)`;
    }
    window.addEventListener("orientationchange", applyOrientation);
    setInterval(applyOrientation, 2000);

    /* ===== ACCESS CHECK ===== */
    async function checkAccess() {
      try {
        const res = await fetch("/api/streams");
        const all = await res.json();
        const stream = all.find(s => s.id === streamId);

        if (stream && stream.camera_access === "protected") {
          console.log("ðŸ”’ Camera: Protected stream detected");
          overlay.style.display = "flex";
          joinBtn.onclick = () => {
            const pass = passInput.value.trim();
            if (!pass) return;
            socket.emit("join", { room: streamId, role: "camera", password: pass });
          };
        } else {
          console.log("ðŸ”“ Camera: Public stream detected");
          overlay.style.display = "none";
          socket.emit("join", { room: streamId, role: "camera" });
        }
      } catch (e) {
        console.warn("Check access failed, defaulting to public join", e);
        overlay.style.display = "none";
        socket.emit("join", { room: streamId, role: "camera" });
      }
    }

    socket.on("join-error", (msg) => {
      overlay.style.display = "flex";
      errorMsg.style.display = "block";
      passInput.value = "";
      passInput.focus();
    });

    socket.on("join-success", () => {
      overlay.style.display = "none";
    });

    /* ===== ISO RECORDING ===== */
    let isoRecorder = null;
    let isoChunks = [];
    let currentIsoSessionId = null;

    socket.on("start-iso", async ({ sessionId }) => {
      console.log("ðŸŽ¥ Starting ISO Recording for Session:", sessionId);
      currentIsoSessionId = sessionId;
      if (!mediaStream) return;

      isoChunks = [];
      try {
        // High Quality Options
        const options = { mimeType: "video/webm;codecs=vp9,opus", videoBitsPerSecond: 2500000 };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          // Fallback
          delete options.mimeType;
        }

        isoRecorder = new MediaRecorder(mediaStream, options);
        isoRecorder.ondataavailable = e => {
          if (e.data && e.data.size > 0) isoChunks.push(e.data);
        };
        isoRecorder.start(1000); // 1s chunks

        // Visual indicator
        liveBadge.textContent = "REC";
        liveBadge.style.background = "#b91c1c";
        liveBadge.style.display = "inline-block";

      } catch (e) {
        console.error("Failed to start ISO recorder:", e);
      }
    });

    socket.on("stop-iso", () => {
      console.log("ðŸ›‘ Stopping ISO Recording");
      if (!isoRecorder || isoRecorder.state === "inactive") return;

      isoRecorder.onstop = () => {
        const blob = new Blob(isoChunks, { type: "video/webm" });
        uploadIso(blob);
      };
      isoRecorder.stop();

      liveBadge.style.display = "none";
    });

    async function uploadIso(blob) {
      console.log("ðŸ“¤ Uploading ISO file using XHR...", blob.size);
      const overlay = document.getElementById("uploadProgressOverlay");
      const fill = document.getElementById("uploadProgressFill");

      overlay.style.display = "flex";
      fill.style.width = "0%";

      liveBadge.textContent = "UPLOADING";
      liveBadge.style.background = "#f59e0b"; // Orange
      liveBadge.style.display = "inline-block";

      const formData = new FormData();
      formData.append("video", blob, `cam_${socket.id}.webm`);
      formData.append("sessionId", currentIsoSessionId || "unknown");
      formData.append("camId", socket.id);

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/api/upload-iso", true);

      // Track progress
      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          fill.style.width = percent + "%";
          socket.emit("iso-upload-progress", { room: streamId, progress: percent });
        }
      };

      xhr.onload = () => {
        try {
          const data = JSON.parse(xhr.responseText);
          if (xhr.status === 200 && data.success) {
            console.log("âœ… Upload complete:", data.filename);
            socket.emit("iso-upload-complete", { room: streamId, filename: data.filename });
            liveBadge.textContent = "DONE";
            liveBadge.style.background = "#10b981"; // Green
            setTimeout(() => {
              liveBadge.style.display = "none";
              overlay.style.display = "none";
            }, 3000);
          } else {
            throw new Error(data.error || "Server rejected upload");
          }
        } catch (e) {
          console.error("Upload process error:", e);
          liveBadge.textContent = "ERROR";
          overlay.style.display = "none";
        }
      };

      xhr.onerror = () => {
        console.error("Network error during upload");
        liveBadge.textContent = "ERROR";
        overlay.style.display = "none";
      };

      xhr.send(formData);
    }

    /* ===== RENDER PROGRESS ===== */
    socket.on("render-progress", ({ progress, status }) => {
      const bar = document.getElementById("renderProgressPanel");
      const fill = document.getElementById("renderProgressFill");
      const text = document.getElementById("renderStatusText");

      if (progress < 0) {
        text.innerText = "Error: " + status;
        fill.style.background = "#ef4444";
        setTimeout(() => { bar.style.display = "none"; }, 5000);
        return;
      }

      bar.style.display = "flex";
      fill.style.width = progress + "%";
      fill.style.background = "#3b82f6";
      text.innerText = status + " (" + progress + "%)";

      if (progress >= 100) {
        setTimeout(() => { bar.style.display = "none"; }, 3000);
      }
    });
  </script>

  <div id="renderProgressPanel"
    style="display:none; position:fixed; bottom:100px; left:20px; right:20px; background:rgba(0,0,0,0.8); padding:16px; border-radius:12px; border:1px solid var(--border); z-index:200; flex-direction:column; gap:8px;">
    <div style="font-size:12px; font-weight:600; color:#94a3b8;" id="renderStatusText">Rendering Video...</div>
    <div style="height:8px; background:#1e293b; border-radius:4px; overflow:hidden;">
      <div id="renderProgressFill" style="width:0%; height:100%; background:#3b82f6; transition: width 0.3s ease;">
      </div>
    </div>
  </div>
</body>

</html>