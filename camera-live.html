<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Camera Live â€“ CourtStream</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <style>
    :root {
      --bg: #0f1115;
      --card: #161922;
      --border: #262b3d;
      --red: #b91c1c;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #fff;
      font-family: system-ui;
    }

    .page {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
    }

    /* HEADER */
    .header {
      height: 56px;
      display: flex;
      align-items: center;
    }

    .header-title {
      flex: 1;
      text-align: center;
      font-size: 15px;
    }

    .badge {
      font-size: 12px;
      color: #22c55e;
    }

    /* PREVIEW */
    .preview {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    video {
      width: 90vw;
      max-width: 420px;
      max-height: 100%;
      background: #000;
      border-radius: 18px;
      object-fit: contain;
      /* NO CROPPING */
      transition: transform .25s ease;
    }

    /* CONTROLS */
    .controls {
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 18px 0 24px;
    }

    .ctrl {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--card);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ctrl.off {
      background: var(--red);
      border-color: var(--red);
    }

    .ctrl.end {
      background: var(--red);
      border-color: var(--red);
    }

    .ctrl svg {
      width: 24px;
      height: 24px;
      fill: #fff;
    }
  </style>
</head>

<body>

  <div class="page">

    <div class="header">
      <div class="header-title">
        <span id="streamTitle">Camera</span>
        <span id="liveBadge" class="badge" style="display:none;">LIVE</span>
      </div>
    </div>

    <div class="preview">
      <video id="video" autoplay muted playsinline></video>
    </div>

    <div class="controls">

      <!-- MIC -->
      <button id="micBtn" class="ctrl" onclick="toggleMic()">
        <svg viewBox="0 0 24 24">
          <path d="M12 14a3 3 0 003-3V5a3 3 0 10-6 0v6a3 3 0 003 3z" />
          <path d="M19 11a7 7 0 01-14 0" />
        </svg>
      </button>

      <!-- CAMERA -->
      <button id="camBtn" class="ctrl" onclick="toggleCam()">
        <svg viewBox="0 0 24 24">
          <path d="M17 10.5V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-3.5l4 4v-11l-4 4z" />
        </svg>
      </button>

      <!-- LEAVE -->
      <button class="ctrl end" onclick="leave()">
        <svg viewBox="0 0 24 24">
          <path d="M21 7.5l-3.5-2v4H10v3h7.5v4z" />
          <path d="M3 5h8v14H3z" />
        </svg>
      </button>

    </div>

  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    /* ===== STATE ===== */
    const streamId = new URLSearchParams(location.search).get("stream");
    const streamName = new URLSearchParams(location.search).get("name");
    const video = document.getElementById("video");
    const micBtn = document.getElementById("micBtn");
    const camBtn = document.getElementById("camBtn");
    const streamTitle = document.getElementById("streamTitle");
    const liveBadge = document.getElementById("liveBadge");

    let mediaStream;
    let videoSender;
    let micOn = true;
    let camOn = true;
    let facing = "environment";
    let directorId = null;
    let isLive = false;
    let videoDevices = [];
    let currentDeviceIndex = 0;
    let hasPickedDefault = false;
    let resolveCameraReady;
    const cameraReady = new Promise(r => { resolveCameraReady = r; });

    const pendingCandidates = []; // Buffer signals until remote description is set

    const socket = io();
    const pc = new RTCPeerConnection({
      iceServers: [
        {
          urls: [
            "stun:stun.cloudflare.com:3478",
            "stun:stun.cloudflare.com:53"
          ]
        },
        {
          urls: [
            "turn:turn.cloudflare.com:3478?transport=udp",
            "turn:turn.cloudflare.com:3478?transport=tcp",
            "turns:turn.cloudflare.com:5349?transport=tcp",
            "turn:turn.cloudflare.com:53?transport=udp",
            "turn:turn.cloudflare.com:80?transport=tcp",
            "turns:turn.cloudflare.com:443?transport=tcp"
          ],
          username: "g07ef1b745ad2a747da14d563e4bfbd538f21945297c2fad25578fb243c68286",
          credential: "3882b29cc1772be95d469efdb14ccd45ed1b79ec8c52d9e0d8070720e093b43d"
        }
      ]
    });

    /* ===== CAMERA ===== */
    async function loadVideoDevices() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      videoDevices = devices.filter(d => d.kind === "videoinput");
      if (!videoDevices.length) return;

      const currentId = mediaStream && mediaStream.getVideoTracks()[0]
        ? mediaStream.getVideoTracks()[0].getSettings().deviceId
        : null;

      if (currentId) {
        const idx = videoDevices.findIndex(d => d.deviceId === currentId);
        if (idx >= 0) currentDeviceIndex = idx;
      }
    }

    function pickDefaultBackCamera() {
      if (!videoDevices.length) return;

      const backIndex = videoDevices.findIndex(d => {
        const label = (d.label || "").toLowerCase();
        return label.includes("back") || label.includes("rear") || label.includes("environment");
      });

      if (backIndex >= 0) {
        currentDeviceIndex = backIndex;
        facing = "environment";
      }
    }

    async function getStreamWithFallback() {
      const constraintsByPriority = [];

      if (videoDevices.length) {
        constraintsByPriority.push({
          video: { deviceId: { exact: videoDevices[currentDeviceIndex].deviceId } },
          audio: true
        });
      }

      constraintsByPriority.push({
        video: { facingMode: { exact: facing } },
        audio: true
      });

      constraintsByPriority.push({
        video: { facingMode: { ideal: facing } },
        audio: true
      });

      let lastError;
      for (const constraints of constraintsByPriority) {
        try {
          return await navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          lastError = err;
        }
      }

      throw lastError;
    }

    async function startCamera() {
      await loadVideoDevices();

      if (!hasPickedDefault) {
        pickDefaultBackCamera();
        hasPickedDefault = true;
      }

      const stream = await getStreamWithFallback();

      video.srcObject = stream;

      if (!mediaStream) {
        stream.getTracks().forEach(t => {
          const sender = pc.addTrack(t, stream);
          if (t.kind === "video") videoSender = sender;
        });
      } else {
        await videoSender.replaceTrack(stream.getVideoTracks()[0]);
        mediaStream.getTracks().forEach(t => t.stop());
      }

      mediaStream = stream;
      if (resolveCameraReady) {
        resolveCameraReady();
        resolveCameraReady = null;
      }
    }
    startCamera();

    /* ===== JOIN ===== */
    const pass = new URLSearchParams(location.search).get("pass") || "";
    socket.emit("join", { room: streamId, role: "camera", password: pass });

    socket.on("join-error", () => {
      alert("Access Denied: Invalid passcode or session expired.");
      location.href = `camera-join.html?stream=${streamId}`;
    });

    /* ===== CONTROLS ===== */
    function toggleMic() {
      micOn = !micOn;
      mediaStream.getAudioTracks()[0].enabled = micOn;
      micBtn.classList.toggle("off", !micOn);
    }

    function toggleCam() {
      camOn = !camOn;
      mediaStream.getVideoTracks()[0].enabled = camOn;
      camBtn.classList.toggle("off", !camOn);
    }

    function leave() {
      pc.close();
      socket.disconnect();
      mediaStream.getTracks().forEach(t => t.stop());
      location.href = "index.html";
    }

    /* ===== ðŸ”‘ AUTO ROTATE PREVIEW WITH PHONE ===== */
    function applyOrientation() {
      let angle = 0;

      if (screen.orientation && screen.orientation.angle !== undefined) {
        angle = screen.orientation.angle;
      } else if (window.orientation !== undefined) {
        angle = window.orientation;
      }

      video.style.transform = `rotate(${angle}deg)`;
    }

    if (screen.orientation) {
      screen.orientation.addEventListener("change", applyOrientation);
    }
    window.addEventListener("orientationchange", applyOrientation);
    applyOrientation();

    /* ===== STREAM TITLE ===== */
    async function updateStreamTitle() {
      let name = streamName;

      if (!name && streamId) {
        try {
          const res = await fetch("/api/streams");
          if (res.ok) {
            const streams = await res.json();
            const match = streams.find(s => s.id === streamId);
            if (match) name = match.name;
          }
        } catch {
          // fallback below
        }
      }

      streamTitle.innerText = name || "Camera";
    }
    updateStreamTitle();

    function setLive(on) {
      isLive = !!on;
      liveBadge.style.display = isLive ? "inline-block" : "none";
    }

    /* ===== WEBRTC ===== */
    pc.onicecandidate = e => {
      if (e.candidate) {
        if (directorId) {
          socket.emit("signal", { to: directorId, data: e.candidate });
        }
      }
    };

    socket.on("signal", async ({ from, data }) => {
      if (!data) return;

      if (data.type === "offer") {
        console.log("ðŸ“¡ Camera: Received offer from director", from);
        directorId = from;
        await cameraReady;
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(data));
          const ans = await pc.createAnswer();
          await pc.setLocalDescription(ans);
          socket.emit("signal", { to: from, data: pc.localDescription });

          // Flush buffered candidates
          while (pendingCandidates.length > 0) {
            const cand = pendingCandidates.shift();
            await pc.addIceCandidate(new RTCIceCandidate(cand)).catch(e => console.warn("ICE error:", e));
          }
        } catch (e) {
          console.error("Signaling error:", e);
        }
        return;
      }

      if (data.candidate) {
        if (pc.remoteDescription) {
          await pc.addIceCandidate(data).catch(e => console.warn("ICE error:", e));
        } else {
          pendingCandidates.push(data);
        }
      }
    });

    socket.on("control", ({ data }) => {
      if (!data || !data.type) return;
      if (data.type === "live") {
        setLive(!!data.on);
      }
    });
  </script>

</body>

</html>